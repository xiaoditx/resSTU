# 研究性学习报告

编写：xiaoditx

校对：马赫阳

### 〇.序言

计算机技术离不了各种编程语言，因此**编程语言的发展可以在侧面上反应计算机技术的发展**，编程语言的每一次演进都能见证着时代对于计算机技术的需求，可以说，编程语言的发展史，就是计算机技术的发展史。

本研究性学习报告将从“编程语言”的历史着手，分析各个时代下不同语言的特征，试图窥见计算机技术的发展历程，同时，也想以一个“中国学生”的身份探究一下**中国在其发展历史的贡献**

本文的基本结构如下：

1. 介绍计算机的诞生史，辅佐理解人类对计算机技术需求的本质
2. 介绍编程语言雏形的逐步完善
3. 简单第一到五代编程语言
4. 分析编程语言的变化

### 一.从2到10——诞生在工业生产下的雏形

人类是一种懒惰的生物，千年前是这样，千年后也是这样，懒惰制造着灾难，但也在推动着技术的进步，计算机可以说就是一种“懒惰”的产物，然而在这一产物诞生之前，仍有一些不可忽视的中间产物，它们无一不对人类的生产生活产生了深刻的影响。

寻找资料时，我们注意到[一篇文章][1]提到了一种名为`提花机`的东西，[百度百科][0]上显示这种物件**最早可以追溯到商代**，同时，我们也注意到了一行与之年代似乎格格不入的描述：

> 花本式提花机出现于东汉，又称花楼。它用线制花本贮存***提花程序***，再用衢线牵引经丝开口。***花本是提花机上贮存纹样信息的一套程序***，它由代表经线的脚子线和代表纬线的耳子线根据纹样要求编织而成。

“程序”，这个词不一般，我们可以给“花本式提花机”起个新名字了，“可编程自动提花机”似乎就很合适。

于是我们甚至可以说，这种改良过后的自动的提花机就是如今所有计算机的祖师爷，而所谓的“花本”，就是世界上最早的编程语言,**花本就是编程语言的雏形，属于最早期的“低级语言”**。

随着丝绸之路的打通，提花机传入欧洲，在数百年后，这个来自中国的古老机器迎来了它的新生——**纸带打孔**的应用

布乔、法尔孔、沃康松、贾卡等人跨越百年，先后将纸带打孔与花本式提花机结合，最终诞生出了计算机的雏形——一种自动的编织机器，能够半自动的处理复杂花纹。

这种“纸带打孔”的想法被延续了下来，之后出现的巴贝奇差分机也沿用了这一路线，到了1888年，霍列瑞斯发明了穿孔制表机，这是二进制第一次在严格意义上作为了输入的“**数据**”存在

<!--

### 二.战火中煅烧的机器

根据收集到的材料，我们发现了一点：编程语言这个东西似乎是在某个时期快速定型的，而这个时期，就是第二次世界大战。

这让我们不禁想到了一个人，即使是没有学习过编程甚至是不会使用计算机，应该都听过他的名字：**艾伦·麦席森·图灵**

“[**英国计算机科学家、数学家、逻辑学家、密码分析学家、理论生物学家，计算机科学之父、人工智能之父，英国皇家学会院士**][8]”这是他的头衔，但不是他的全部头衔，图灵，对于计算机技术，是绝对的“祖师爷”（事实上，现今也有很多人使用这个叫法）图灵机、图灵测试，甚至是苹果的logo，都是因他而存在。

就是这么样一个人，提出了可以使用机器“**模仿**”人的思维活动，也正是他，在第二次世界大战中破解了大量的密码，**扭转了战局**，拯救了数万士兵的性命。

这里不仅引发了我们的思考：如果没有第二次世界大战，图灵**还能有**如此名声吗？

或许答案是：没有，他会成为一位伟大的人，但也只是像[加里][6]或是他的老师[邱奇][7]一样，只被相关从业人员记住，在历史上也只是留下短短几行文字（[百度百科上对于加里的描述][6]不超过10行）

于是，我们可以说，图灵是生而逢时的英雄，而战争，是令他也是令计算机科学展现自身潜力的催化剂。

同样是由于战争的计算需求，**1946年2月14日**，ENIAC，也就是世界上第二台电子计算机、第一台通用计算机在美国诞生了，这一天正好是**情人节**，战征、科学、生活，此时似乎交织成了一个点，编织出了一个新生的学科，这成为了一切的浪漫开始。

由此我们发现，战争，催化了计算技术的初步发展。

-->

### 三.第一代编程语言——机器语言

即使到目前为止，人类的技术也**不足以支撑**机器去理解诸如汉语 英语 日语 德语之类的语言，为了能和生产出来的机器“交流”，人们只好用高低电平代表**0和1**来和机器“交流”

这种只有0与1构成的“语言”就是**机器语言**，也就是**第一代计算机语言**

下面是一个示例，我们姑且不去探究它干了什么，之去体会一下这种语言的直接观感：

```
二进制表示：
10001011 01000101 00000100
01011011
10001001 11000011

十六进制表示：
8b 45 04
5b
89 c3
```
是不是看不懂这几行在干什么？那就对了，即使是专业的程序员来了也不一定能立刻看出这三行内容是在干什么，因为0和1的掺杂导致所有语句看起来都很相似，**人类很难凭借所谓肌肉记忆之类的东西快速识别**。

假如现在我们不小心写错了一个字符：

```
错误的：
10001011 01000101 00000100
01011011
10001101 11000011

正确的：
10001011 01000101 00000100
01011011
10001001 11000011
```
有人可以做到一眼看出哪个是错的吗？大概是没有的。事实上，刚刚写的三行甚至**不足以**支撑一次加法运算，纠错难度都尚且如此之高，实际使用时困难可想而知。

这就引出了机器语言的优点与弊病：

优点如下

- 最接近底层，运行**足够快**
- 机器可以**直接识别**运行，无需辅助的程序
- 不会出现多余无用的内容（程序**体积小**）

缺点如下：

- **记忆难度大**
- 直面底层，学习难度大
- 对于机器的依赖性强，一种机器一种结构，**难以移植**
- **只有0、1**，容易写错且纠错困难

不禁想到了王爽在《汇编语言》中此般描述：

> 书写和阅读机器码程序不是一件简单的工作，要记住所有抽象的二进制码。上面只是一个非常简单的小程序就暴露了机器码的灰色难懂和不易查错。写如此小的一个程序尚且如此，实际上一个有用的程序至少要有几十行机器码，那么，情况将怎么样呢？

虽然机器语言很难使用，但它也确实**作为主要的编程方式**流行了很多年，杨磊导演拍摄的《三体》电视剧中就出现了这样一幕：叶文洁在红安基地操作机器时，用了一节打满孔洞的纸带塞入其中，这就是运用之前说的***纸带打孔***写的机器语言程序，在当时几乎是唯一与机器交流的方法了。

值得注意的是，虽然后来出现了很多其他编程语言，但机器仍然是只能看懂机器语言的，也就是无论用什么语言，都只是对机器语言的**简化**，最终输出的都还是机器语言文件，只是**用户不需要关注**罢了

### 三.汇编语言：程序员们对自然语言的第一次追逐

既然机器语言那么难写，那该怎么办呢？程序员们想了个办法：既然直接跟机器“聊天”有些困难，那我**找个翻译不就好了**？于是**汇编语言**便诞生了。

百度百科这么定义汇编语言：

> 汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。

简单来说，汇编语言就像是一个万能的翻译官，这位“翻译官”制定了一种语言，当你需要和任意一个机器“对话”时，只要找到这位“翻译官”，对着他说出它制定的那套语言，他就可以根据情况用不同的表述转述给机器

举个例子，A机器规定`0000`是加法运算，B机器规定`1010`是加法运算，此时，汇编语言规定了加法运算就是`+`,那么我们写程序时只要写`+`就行了，汇编语言针对A机器，会传述给它`0000`，而对于B机器则是`1010`

发现了吗，汇编语言在一定程度上解决了机器语言对机器的强依赖性，同时，通过诸如把`0000`变到`+`的操作，使得编写程序更加直观、更好记忆（是`1 0000 2`好记好写还是`1+2`更加方便呢？这就很明显了吧）

因此，汇编语言有时也被称作助记符，也就是**辅助记忆的文本**的意思，参照如下[定义][4]：

> 助记符（mnemonic）是便于人们记忆、并能描述指令功能和指令操作数的符号，助记符是表明指令功能的英语单词或其缩写。

汇编的引入使得记忆不再枯燥且难以理解，比如有`MOV`、`ADD`、`CALL`等命令，只要稍微有些英语基础就可以很好的理解，也就能比二进制更加快速的记住了。

考虑到不同设计的机器之间有一些不可忽视的不同，汇编也衍生出了不同的版本，诸如IBM PC汇编、ARM汇编、GNU ASM、MASM、NASM等等，这里不去展开。

这里引用[一篇文章][5]中对汇编语言的评价：

> 汇编语言的出现，让程序员们从繁琐的二进制编程中解放出来，能够更加专注于程序的逻辑和功能实现，为计算机软件的发展奠定了重要基础

总的来说，汇编语言就是让人达到“知其然而不知其所以然”的状态，着对于计算机技术的学习在大多数时候实际上是个好的状态，因为这样就可以摆脱繁琐的底层原理，当想用计算机解决某个问题时，**就能去直接想使用怎么样的算法，而不是先看看机器的底层架构是如何的**。

### 四.函数到计算




### 后记

这个主题是我很久以前便想要开始研究的，借此次学校的组织得以实现，小组的各位成员忙前忙后，各自出了不少力气，最终将我的这个想法给实现了，这里要向他们的劳苦付出表示感谢。

组长马赫阳，作为多次参加算法竞赛的“算法人”，总能在关键问题上找到正确的答案或是及时的寻找到帮助力量，这里也要向他义无反顾地带领小组成员一路向前表示感谢。

作为文档的编写者，我就不如组长那般有如此身后的专业素养，和转于一个研究方向的钻劲了，只好接着自己学的不精的知识与自诩尚可的文学水平，苟且写下了这些最终呈现的文字，终究是有些惶恐，担心写下的内容存在瑕疵，如果各位读者能够发现文章中的错误，无论大小，万望可以在GitHub上的Issue中提交。

### 参考文献

- [百度百科-提花机][0]
- 川合秀实《三十天自制操作系统》| 人民邮电出版社
- [编程语言发展简史][1]
- [作为程序员必须知道的编程语言编年史][2]
- 王爽《汇编语言》| 清华大学出版社
- [百度百科-汇编语言][3]
- [百度百科-助记符][4]
- [从机器到智能：汇编语言的前世今生与未来][5]
- [百度百科-哈斯凯尔·加里][6]
- [百度百科-阿隆佐·邱奇][7]
- [百度百科-艾伦·麦席森·图灵][8]
- [图灵100：纪念图灵诞辰百年-国家数学于交叉科学中心][9]
- [艾伦•图灵因性取向遭“化学阉割”英“计算机科学之父”半世纪后雪沉冤][10]
- [图灵机与控制论之分歧，一切为了人类心智的荣耀！][11]

### 声明

文中汇编代码转到机器码由[Online x86 and x64 Intel Instruction Assembler](https://defuse.ca/online-x86-assembler.htm#disassembly)实现，不确定是否存在转换问题，因此不具参考价值，只用于辅助理解机器语言的不便捷性。

对于一些在互联网上不常被提及因而分布零星难以查证的内容，在必要时借助了`DeepSeek-V3`进行了联网搜索整合，虽然后期经过了人工复核，仍不能保证完全正确，在引用时通常会使用“**=D**”标记，这些内容不具参考价值





[0]:https://baike.baidu.com/item/%E6%8F%90%E8%8A%B1%E6%9C%BA/304537

[1]:https://blog.csdn.net/lywstuding/article/details/123216486

[2]:https://www.runoob.com/w3cnote/history-of-programming-languages-must-know.html

[3]:https://baike.baidu.com/item/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/61826

[4]:https://baike.baidu.com/item/%E5%8A%A9%E8%AE%B0%E7%AC%A6/489287

[5]:https://zhuanlan.zhihu.com/p/24327574773

[6]:https://baike.baidu.com/item/%E5%93%88%E6%96%AF%E5%87%AF%E5%B0%94%C2%B7%E5%8A%A0%E9%87%8C/10234416

[7]:https://baike.baidu.com/item/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87/5029065

[8]:https://baike.baidu.com/item/%E8%89%BE%E4%BC%A6%C2%B7%E9%BA%A6%E5%B8%AD%E6%A3%AE%C2%B7%E5%9B%BE%E7%81%B5/3940576#reference-21

[9]:http://www.ncmis.cas.cn/kxcb/tuling100/

[10]:https://news.sina.com.cn/c/2009-09-22/124016339049s.shtml

[11]:http://iwh.cssn.cn/xscg/zmsyzts/201909/t20190906_5225551.shtml